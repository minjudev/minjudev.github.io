해당 글은 구름EDU의 **"한 눈에 끝내는 Node.js"** 를 학습한 뒤 요약해 작성한 글입니다.

## 4. 스코프와 호이스팅
### 1) 유효 범위(Scope)란?
Scope의 사전적 의미는 범위이다.  
자바스크립트에서 스코프란 어떤 변수들에 접근할 수 있는지를 정의하며, 
**전역(global)** 과 **지역(local)** 스코프로 나눌 수 있다.  
또한, 대부분의 언어들은 Block-level scope를 사용하여 변수 선언이 코드 블록 단위로 유효하다.  
하지만 **자바스크립트는 Function-level scope를 사용**한다. 따라서, 함수 블록 내에서
선언된 변수는 함수 블록 내에서만 참조 가능하고 함수 외부에서는 참조할 수 없다.

단, 자바스크립트 ES6부터는 const와 let을 이용해 Block-level scope도 지원하기 시작했다.  
**const와 let**은 **블록 레벨 스코프**, **var**는 **함수 레벨 스코프**임을 잘 기억해두자.  

### 2) 전역 스코프(Global scope)와 지역 스코프(Local scope)
#### (1) 전역 스코프(Global scope)
**함수 바깥이나 중괄호 바깥에 선언된 변수**는 전역 스코프에 정의된 변수이다.    
전역 스코프에 변수를 선언하면 코드 어디에서나 해당 변수를 사용할 수 있다.   

#### (2) 지역 스코프(Local scope)
**함수 내의 범위**로, 각각의 함수들마다 자신의 지역 스코프를 가지고 있다.  
어떤 함수 내의 지역 스코프에 선언된 변수가 있다면, 해당 함수 바깥 범위에서는 함수 내의 변수를 참조할 수 없다. 
```js
var global_scope = 'global';

var local_function = function() {
  var local_scope = 'local';
  console.log(global_scope); // 'global'
  console.log(local_scope); // 'local'
};

console.log(local_scope); // Uncaught ReferenceError: local_scope is not defined
```

*전역 스코프가 더 편하다고 느낄 수 있지만, 변수의 이름이 충돌할 가능성이 있기 때문에 전역 스코프에 변수 선언을 하지 않는 것이 좋다.*

### 3) 유효 범위 체인(Scope Chain)
아래 코드와 같이 함수를 정의하면, **제일 안쪽에 있는 함수인 inner는 그 위쪽의 범위까지 흡수**하게 된다.  
외부에서는 안에 있는 함수의 변수를 참조할 수 없지만, 안에 있는 함수는 외부의 변수를 사용할 수 있는 것이다.  
이러한 메커니즘을 유효 범위 체인(Scope Chain) 이라고 한다.
```js
var a = 1;

function outer() {
  var b = 2;
  console.log(a); // 1
  
  function inner() {
    var c = 3;
    console.log(b); 
    console.log(a);
  }
  
  inner(); // 2 1
}
outer();

console.log(c); // Uncaught ReferenceError: c is not defined
```

inner 함수에서는 a 변수를 참조할 때 먼저 자신의 스코프에서 a를 찾고,  
자신의 스코프에 a 변수가 없으면 상위 스코프인 outer 함수의 스코프에서 a를 찾는다.  
상위 스코프에도 a가 없다면 또 다시 상위 스코프인 전역 범위로 올라가 a를 찾는다.  
만약, 전역 스코프에도 찾는 변수가 없다면 not defined 에러를 출력한다.  
이렇게 계속해서 체인처럼 연달아 상위 스코프를 참조하기 때문에 **스코프 체인**이라고 이름 지어졌다.

### 4) 정적 범위(Lexical scope)
렉시컬 스코프 또한 기본적인 자바스크립트의 특징 중 하나이다.  
렉시컬 스코프란, 함수를 어디서 호출하는지가 아니라 **어떤 스코프에 선언하였는지에 따라 결정**된다.  
```js
var text = 'global';

function foo() {
  console.log(text);
}

function bar() {
  var text = 'bar';
  foo();
}

bar(); // 'global'
```

여기서 중요한 것은, **함수를 어디서 호출하는지가 아니라 함수가 처음 선언되었을 때 어떤 스코프에 있는지**가 중요하다.  
따라서 함수 foo가 bar에서 호출되든 어떤 함수 안에서 호출되든지 상관없이,  
먼저 처음에는 무조건 자기 자신의 스코프에서 찾아보고 그 이후에는 전역 스코프에서 찾게 된다.  
이러한 이유로 함수 bar를 호출했을 때 'text'가 출력되는 것이 아니라 'global'이 출력된다.  

### 5) 호이스팅(hoisting)
hoisting의 사전적 의미는 끌어 올리기라는 뜻이다.  
이는 함수 안에서 **변수를 선언할 때 어떤 위치에 있든 함수의 시작 위치로 끌어올리는 현상**이다.  
단, 선언 부분만 위로 끌어올리고 값을 대입하는 부분은 그대로 남아있는다.  
```js
function foo() {
  console.log(a); // undefined
  var a = 100;
  console.log(a); // 100
}

foo();
```
자바스크립트는 호이스팅을 통해 a의 선언을 함수의 시작 부분에서 해주기 때문에, 에러 없이 undefined가 출력된다.  
위의 코드는 아래 코드와 같다고 볼 수 있다.
```js
function foo() {
  var a;
  console.log(a); // undefined
  var a = 100;
  console.log(a); // 100
}

foo();
```

변수 호이스팅과 마찬가지로, 함수 호이스팅 또한 비슷하게 작동된다.
```js
foo();

function foo() {
  console.log('출력');
}
```
위 코드는 변수 호이스팅처럼 함수에 대한 선언이 위로 끌어올려지기 때문에 정상적으로 작동한다.  
하지만 아래와 같은 함수 표현식의 경우에서는 오류가 발생하는 것을 볼 수 있다.
```js
foo(); // Uncaught TypeError: foo is not a function

var foo = function() {
  console.log('출력');
};
```
오류가 발생하는 이유를 아래 코드를 통해 살펴보겠다.
```js
var foo;

foo(); // foo is not a function

foo = function() {
  console.log('출력');
};
```
위와 같이 foo 선언을 위로 호이스팅 해버리므로, 아래 줄 코드에서 foo가 실행될 때는 함수가 아니라 아직은 변수로만 선언이 된 상태인 것이다. 
따라서 foo는 함수가 아니라는 에러 메세지를 보게 된다.  

이처럼 함수에 대한 호이스팅은 혼란을 줄 수 있기 때문에, 함수를 호출하기 전에 최상단에 선언하는 것이 좋다.

## 5. 클로저
