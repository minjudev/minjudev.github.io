# 4월 12일 (월)
## 공부한 내용
### 자바 국비지원 수업
- **오전(백엔드)**  
  - 자바
    - 오전에는 그동안 배운 내용을 복습해보고, **인터페이스 구현을 위한 중첩 클래스, 익명 클래스**에 대해 알아보았다. 
    1. **복습**
        ```txt
        객체지향

        캡슐(화)
        - 은닉성(private, public, protected)

        상속(has a / is a)
        - has a(composition/association)
        - is a(single/multi(x) : extends, implements)

        추상화
        - 공통분모: abstract 클래스, abstract 메소드

        다형성
        - 절차의 일부분 분리 가능 -> 인터페이스 필요
        - 절차의 분리와 결합이 이루어짐
        - 다양한 형식(절차)을 갖는 성질
        ```
    2. **인터페이스 구현 시 발생하는 문제점**
       - 자식 클래스에서 인터페이스 구현 시 인터페이스 내에 부모 클래스의 메소드와 같은 이름의 메소드가 있다면,   
       부모 클래스의 메소드를 오버라이드하는 일이 발생한다. 
       - 이러한 문제점을 중첩 클래스와 익명 클래스를 사용하여 해결할 수 있다.
    4. **인터페이스 구현을 위한 중첩 클래스(Nested Class)**
       - 중첩 클래스란 클래스 내에 또 클래스를 구현하는 것이다.
          ```java
          // 다중 상속의 문제점(is a 상속 + 인터페이스 구현): 부모 클래스의 메소드를 오버라이드하게 됨
          public class YBMExamConsole extends ExamConsole /*implements Banner*/ {

              public YBMExamConsole() {
                  // 중첩 클래스
                  class XXX implements Banner {

                      @Override
                      public void print() {
                          System.out.println("----------------------------------");
                          System.out.println("            YBM 성적 출력           ");
                          System.out.println("----------------------------------");     
                      }

                      @Override
                      public void printEnd() {
                        System.out.println("----------------------------------");		
                      }
                }
         }

              // 중첩 클래스 생성
              XXX x = new XXX();
              // 구현한 인터페이스 끼워주기
              setBanner(x);
          ```
    5. **인터페이스 구현을 위한 익명 클래스(Anonymous Class)**
        - 인터페이스를 구현하는 것이 목적이면 클래스를 따로 정의하지 말고 메소드 안에서 클래스를 정의해보자.
        - 메소드 안에서 정의된 클래스 - 다른 곳에서는 절대 볼 수 없음
            ```java
            public class YBMExamConsole extends ExamConsole /*implements Banner*/ {

                public YBMExamConsole() {
                    // 익명 클래스
                    // 인터페이스를 구현한 무명의 클래스를 new 연산자로 생성하게 해서, 그걸 아래 setBanner()에서 세팅할 수 있게 함
                    Banner banner = new Banner() {

                        @Override
                        public void print() {
                            System.out.println("----------------------------------");
                            System.out.println("            YBM 성적 출력           ");
                            System.out.println("----------------------------------");
                        }

                        @Override
                        public void printEnd() {
                            System.out.println("----------------------------------");		
                        }

                    };

                    setBanner(banner);
                 }
            }
            ```
  - 서블릿
    - **사용자가 form에 값을 입력하면 그 값을 얻어와서 더한 후 더한 값을 출력하는 코드**를 작성하였다.
    1. **HTML 코드**
        ```html
        <body>
          <section>
            <h1>계산기</h1>
            <div>
              <!-- 서버 코드에 add라는 url을 보내겠다는 의미 -->
              <form action="/add">
                <!-- name 속성을 지정해주어야 사용자의 입력값을 서버로 전달 가능 -->
                <input type="text" name="x">+<input type="text" name="y"><br>
                <input type="submit" value="덧셈"><span>0</span>
              </form>
            </div>
          </section>
        </body>
        ```
    3. **서블릿 코드**
        ```java
        @WebServlet("/add")
          // HttpServlet을 상속받기
          public class Calc extends HttpServlet {	

            // service 함수가 main 함수를 대신함
            @Override
            protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
              // 사용자 form 입력 시 x로 들어온 값은 정수 x 변수에 담기
              int x = Integer.parseInt(req.getParameter("x"));
              // 사용자 form 입력 시 y로 들어온 값은 정수 y 변수에 담기
              int y = Integer.parseInt(req.getParameter("y"));

              // x와 y를 더한 값을 웹 브라우저에 출력하기
              PrintWriter out = resp.getWriter();
              out.println(x+y);

              System.out.println("calc");
            }
        }
        ```
- **오후(프론트엔드)**
  - CSS 
    - 오후에는 **CSS에서 값을 변수화하는 방법**에 대해 배워보았다.
    1. **값을 변수화하기**
      ```css
      body {
          font-family: "돋음", Arial, Helvetica, sans-serif;
          font-size: 11px;
          color: #979797;

          --color-strong: #ff6a00; /*변수화*/
      }

      .page-status span{
          color: var(--color-strong); /*변수 사용하기*/
          font-weight: bold;
      }
      ```
    - JS에서는 **함수를 정의하는 방법과 클로저**에 대해 알아보았다.
    1. **JavaScript - 함수**
        - 함수를 정의하는 세 가지 방법
          ```js
          // 1번
          var add = new Function("x, y", "return x + y);

          // 2번
          var add = function(x, y) {
              return x + y;
          }

          // 3번
          function add(x, y) {
              return x + y;
          }
          ```
     2. **JavaScript - 클로저**   
        ![1 (27) (2)](https://user-images.githubusercontent.com/53208493/114406393-7901b000-9be2-11eb-816c-fd452bbec1f2.png)   
        - 왼쪽 f1() 함수에서 변수 a의 생명주기는 함수 f1() 시작한 후부터 끝나기 전까지(점선 표시) 이다.
        - 하지만, 오른쪽 f1() 함수에서 f1() 함수가 끝나도 변수 a의 생명 주기는 끝나지 않는다.
          - f라는 객체가 사라질 때 a도 함께 사라지게 된다.
          - 즉, 여기서 클로저는 f가 가리키는 f2() 함수이다.

<br>

# 4월 13일 (화)
## 공부한 내용
### 자바 국비지원 수업
- **오전(백엔드)**  
  - 오전에는 **한글 깨짐 문제를 해결하기 위해 인코딩 관련 코드를 작성**하고, **GET과 POST 요청**에 대해 알아보았다.
    1. **한글 깨짐 문제 해결**
        ```java
        resp.setCharacterEncoding("UTF-8"); /*UTF-8로 인코딩해서 응답을 보내는 것*/
        resp.setContentType("text/html;charset-UTF-8"); /*브라우저가 읽는 방식*/ /*응답 헤더로 이 문서가 UTF-8이라는 것을 알려주는 것*/
        ```
    3. **GET과 POST 요청**
        - GET 요청: 가져오는 것, 서버로부터 정보를 조회하기 위해 설계된 메소드
        - POST 요청: 수행하는 것, 리소스를 생성/변경하기 위해 설계된 메소드
- **오후(프론트엔드)**  
  - 오후에는 **언어, 플랫폼, API의 역할 및 연관관계**와 자바스크립트의 **Browser Object**에 대해 알아보았다.
    1. **언어, 플랫폼, API**
        - 언어: 연산이나 절차를 만들기 위한 명령어의 집합
        - 플랫폼: 절차를 만들 때 사용할 수 있는 도구, 재료, 기반 
        - API: 언어에서 플랫폼을 사용 가능하게 하는 인터페이스
    2. **Browser Object**
        - 브라우저를 활용할 수 있도록 도와주는 API: Browser Object
        - alert()
          ```js
          var x = 3;
          var y = 0;
          window.alert(x+y);
          ```
        - prompt()
          ```js
          var x, y;
          x = prompt("x 값을 입력하세요", 0);
          y = prompt("y 값을 입력1하세요", 0);
          
          x = parseInt(x);
          y = parseInt(y);
          alert(x+y);
          ```


<br>


# 4월 14일 (수)
## 공부한 내용
### 자바 국비지원 수업
- **오전(백엔드)**
  - 오전에는 **서블릿에서 GET 요청과 POST 요청 코드를 분리해보았고, 쓰레드, 서블릿의 생명주기**에 대해 알아보았다.  
    1. **GET 요청과 POST 요청 코드 분리하기**
        - 서버에서는 사용자의 요청이 GET 요청인지 POST 요청인지 알 필요가 있는데, service 함수로 전달되는 매개변수 req가 그 정보를 알 수 있게 해준다.
        - 만약, 사용자가 POST 요청을 하면 검사 도구 > 요청 헤더 > General 탭에서 Request Method가 POST인 것을 확인할 수 있다.
        ![1](https://user-images.githubusercontent.com/53208493/114653253-976ec500-9d22-11eb-8903-1efedf850dff.PNG)
        - 이를 활용해 GET 요청과 POST 요청 코드를 분리해보자.
          ```java
          // 값을 꺼내는 작업과 변환하는 작업은 POST 요청이 왔을 때만 실행되게 하기
          if(req.getMethod().equals("POST")) { // Request Method가 POST일 때만 아래 코드 실행
            str_x = req.getParameter("x");
            if(str_x != null && !str_x.equals("")) 
              x = Integer.parseInt(str_x);

            str_y = req.getParameter("y");
            if(str_y != null && !str_y.equals("")) 
              y = Integer.parseInt(str_y);

            result = x + y;
          }
          ```
    3. **쓰레드**  
        ![1 (28)](https://user-images.githubusercontent.com/53208493/114653797-ccc7e280-9d23-11eb-9354-7fb8863636c0.png)   
        - 하나의 프로세스에서 `fork()` 함수를 사용해 자식 프로세스를 만들어서 여러 개의 흐름을 처리할 수 있다.
        - 하지만 이런 방식에서는 두 가지의 큰 문제점이 존재한다.   
          **1. 프로세스 간의 데이터 공유**   
          **2. 컨텍스트 스위칭에 대한 부담**       
        - 이를 해결하기 위해 **쓰레드**를 사용하자.   
        ![1 (29)](https://user-images.githubusercontent.com/53208493/114653793-c9ccf200-9d23-11eb-9a84-4f37c80115b2.png)   
        - main 함수 안에 find 함수가 존재하는데, find 함수가 실행될 동안 main 함수도 같이 실행되게 하기 위해서 쓰레드를 사용하자.
        - `new Thread()` 내에 find() 함수를 넣으면 두 함수가 동시에 실행될 수 있다.
        - 이렇게 되면 함수가 동시에 실행되게 하기 위한 스택이 2개 만들어지고, 이를 통해 heap 영역의 데이터 공유가 원활하게 되면서 함수 간 스위칭도 원활하게 된다.
    5. **서블릿의 생명주기**   
        ![1 (30) (1)](https://user-images.githubusercontent.com/53208493/114654372-02210000-9d25-11eb-86ee-fe2015c4d5af.png)
        - 사용자가 WAS에 요청을 하게 된다.
        - WAS는 서블릿을 실행하기 전에 먼저 메모리에 로드되어있는지 확인한다.
        - 메모리에 없다면 서블릿을 메모리에 올려 객체화한다.
        - 객체화되면 객체가 가지고 있는 기능 중 init()이라는 멤버 메소드를 실행한다.
        - 그런 다음, 쓰레드를 만들고 service() 함수가 실행된다.
        - 일정 시간이 지나 사용되지 않는 서블릿은 destroy() 함수를 통해 메모리에서 사라지게 만든다.
    7. **doGet(), doPost()**
        - 이전에는 service 함수가 사용자의 get과 post 요청을 모두 처리했는데, 이렇게 하지 않고 **각 요청에 특화된 함수를 오버라이드해서 사용**할 수 있다.
          ```java
          // doGet 메소드
          @Override
          protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

            resp.setCharacterEncoding("UTF-8"); /*UTF-8로 인코딩해서 응답을 보내는 것*/
            resp.setContentType("text/html;charset-UTF-8"); /*브라우저가 읽는 방식*/ /*응답 헤더로 이 문서가 UTF-8이라는 것을 알려주는 것*/

            int x = 0;
            int y = 0;
            int result = 0;
            String str_x = null;
            String str_y = null;

            // resp.sendRedirect("/add?r="+result)를 통해 얻은 데이터값을 사용하자.
            String str_r = req.getParameter("r");

            if(str_r != null)
              result = Integer.parseInt(str_r); 

            PrintWriter out = resp.getWriter();		

            out.write("<!DOCTYPE html>");
            out.write("<html>");
            out.write("<head>");
          //out.write("<meta charset=\"UTF-8\">"); /*브라우저에게 내 문서는 UTF로 만들어졌다고 알려주는 것, 브라우저가 문서를 읽을 때 UTF-8로 읽음*/
            out.write("<title>Insert title here</title>");
            out.write("</head>");
            out.write("<body>");
            out.write("	<section>");
            out.write("		<h1>계산기</h1>");

            if(str_x != null && str_y != null)
              out.write("		<div>"+x+"+"+y+"=</div>");

            out.write("		<div>");
            out.write("			<form action=\"/add\" method=\"post\">"); /*폼 전달 방식이 post이므로 post 메소드를 사용하자*/ /*get: 기본 요청*/
            out.write("				<input type=\"text\" name=\"x\">+<input type=\"text\" name=\"y\"><br>");
            out.write("				<input type=\"submit\" value=\"덧셈\"><span>"+ result +"</span>");
            out.write("			</form>");
            out.write("		</div>");
            out.write("	</section>");
            out.write("</body>");
            out.write("</html>");	

          }
          ```

          ```java
          // doPost 메소드
          @Override
          protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

            int x = 0;
            int y = 0;
            int result = 0;
            String str_x = null;
            String str_y = null;

            str_x = req.getParameter("x"); 
            if(str_x != null && !str_x.equals("")) 
              x = Integer.parseInt(str_x);

            str_y = req.getParameter("y");
            if(str_y != null && !str_y.equals("")) 
              y = Integer.parseInt(str_y);

            result = x + y;

            // 상태 유지, 데이터 전달 방법이 필요
            // POST한 결과를 가지고 GET 요청하기 -> 웹의 흐름에 맞지 않음

            // get 요청을 하면서 get을 처리하는 로직에게 내가 만든 값 또는 상태를 전달할 수 있는 방법 필요
            // 1. 파일을 이용
            // 2. 서블릿의 저장소(Application/Session/Request/Cookie/...)를 이용
            // 3. QueryString을 이용

            // POST 요청으로 왔지만 새롭게 GET 요청을 하고 싶을 때 사용
            // 3번 방법을 이용해 url을 보낼 때 데이터값을 함께 보내자.
            resp.sendRedirect("/add?r="+result);

          }
          ```
- **오후(프론트엔드)**
  - 오후에는 수업에서 만들고 있는 **웹페이지의 CSS 스타일을 수정**하고, 자바스크립트의 **Browser Object, Document Object**의 다양한 기능에 대해 알아보았다.
    1. **Browser Object**
        - alert()
        - prompt()
        - confirm()
          ```js
          var result = window.confirm("정말 삭제하시겠습니까?");
          console.log(result); // 화면에 나오는 팝업창에서 확인을 누르면 true가, 취소를 누르면 false가 출력됨
          ```
    3. **Document Object**
        - write()
          ```js
          var html = "<span>안녕하세요!</span>";
          window.document.write(html); // 웹브라우저 화면에 '안녕하세요!'가 출력됨
          ```
    4. **스크립트 코드 작성 영역**   
        ![1 (31) (1)](https://user-images.githubusercontent.com/53208493/114674900-a8c7c980-9d42-11eb-8b2d-7df8264d33cc.png)   
        - 페이지가 읽혀질 때 실행되는 영역: `<script>` 태그 내에 코드 작성하기
          ```html
          <h1 id="asideTitle">고객센터</h1>
          <script>
              var html = "<span>안녕하세요!</span>";
              asideTitle.innerHTML = html; 
          </script>
          ```
        - 이벤트가 발생할 때 실행되는 영역: 이벤트 관련 속성에 코드 작성하기
          ```html
          <h1 id="asideTitle" onclick="console.log('클릭');">고객센터</h1>
          ```
