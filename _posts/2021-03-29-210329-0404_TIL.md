# 3월 29일 (월)
## 공부한 내용
### 자바 국비지원 수업
- **오전(백엔드)**
  - 오늘은 지난 시간에 배운 **객체지향 프로그래밍의 의미를 다시 복습해보고, 이를 설계하는 방법**에 대해 알아보았다.
    1.  **객체지향 프로그래밍**
        - 객체지향이란?  
          행위를 중심에 두는 것이 아닌 객체를 중심에 두고, 객체에서 출발하는 프로그래밍
    2. **객체지향 프로그래밍을 구현하는 순서**
      ![1번](https://user-images.githubusercontent.com/53208493/112991503-27990000-91a2-11eb-88ac-b30505cfb355.png)    
          1. 구현하고자 하는 프로그램에 필요한 개체를 찾는다.
          2. 그 개체가 서비스해야하는 함수, 기능을 정의한다.
          3. 기능의 절차를 코드로 구현한다.
    3. **예제**
      ![2번](https://user-images.githubusercontent.com/53208493/112991504-28319680-91a2-11eb-9296-248e3b30e966.png)     
        1. 개체: 사람, 자동차, 비행기
        2. 개체가 서비스해야하는 함수
            - 사람
              - 끝내다(일)
              - 쉬다
              - 탈곡하다(쌀)
              - 지고 가다(물동이)
              - 쓰다(모자)
            - 자동차
              - 열다(본네트)
              - 가다(오솔길)
            - 비행기
              - 날다
            ```java
            class 사람 { // 구현하고자 하는 프로그램에 필요한 개체
              public void 쉬다() { // 개체가 서비스하는 함수
              
              }
            }
            ```
- **오후(프론트엔드)**
  - **background에 이미지를 중복적이지 않게 설정하는 방법과 Pseudo class**에 대해 알아보았다.
    1. **background 이미지를 중복적이지 않게 설정하기**
        ```css
        .main-menu>ul>li {
            padding-left: 24px;
            background: url(../images/bg-main-menu-vsp.png) no-repeat 12px center; 
        }
        ```
        - `no-repeat 12px center`  
          배경 이미지가 반복해서 나오지 않게 하면서 x축으로는 12px 이동, y축에서는 center에 오도록 설정한다.
    3. **Pseudo class**
        - 단순한 선택자로는 표현할 수 없는 것을 select하는 선택자
        ```css
        .main-menu>ul>li:first-child { /* pseudo class */
            padding-left: 0;
            background: none;
        }
        
        .main-menu>ul>li:nth-child(2) { /* pseudo class */
            padding-left: 0;
            background: none;
        }
        
         .main-menu>ul>li>a:hover { /* 마우스 커서가 링크 위 오버될 때 선택 */
            padding-left: 0;
            background: none;
        }
        ```

<br>

# 3월 30일 (화)
## 공부한 내용
### 자바 국비지원 수업
- **오전(백엔드)**
  - 오전에는 **구조적 프로그래밍과 객체지향 프로그래밍의 차이점  Has A 상속**에 대해 배워보았다.
    1. **구조적 프로그래밍과 객체지향 프로그래밍의 차이**
        - 절차를 나누는 방법(함수를 나누는 기준)에서의 차이
          - 구조적: 중첩/복잡도가 높아지는 부분에서 코드를 나눔
          - 객체지향적: 구조적에서 절차를 나누는 기준 + 객체가 서비스하는 단위로 코드를 나눔
        - 함수를 정리하는 방법에서의 차이
          - 구조적: 데이터 구조 + 함수를 하나로 묶어서 정리
          - 객체지향적: 캡슐화된 함수를 그 객체의 행위로 보는 방식으로 정리
    3. **상속**
        - 상속이란? 능력/기능을 제공받는 것을 뜻함
        - Has A 상속: 어떤 클래스가 다른 객체를 멤버로 가지고 있는 것, 그래서 this를 이용해 멤버로 가지게 된 객체를 사용할 수 있다.
          - Composition Has A 상속: 일체형
          - Association Has A 상속: 분리형
            ```java
            // A 객체가 B 객체를 Composition으로 Has 하게 하자.
            class A {
                private B b;

                public A() { // A 객체를 생성할 때 B 객체도 함께 생성되게 하기
                  b = new B();
                }
            }
            ```
            ```java
            // Program.java
            public class Program {

              public static void main(String[] args) {
                Lotto lotto = new Lotto();
                lotto.gen();

                // 객체지향
                // lotto를 이용해서 출력을 담당하는 객체
                // lotto를 출력하는 역할자에 중심을 둬서 출력 담당 객체를 만듦
                LottoConsole console = new LottoConsole(lotto);                      
                console.print();
              }

            }
            ```
            ```java
            // LottoConsole.java
            public class LottoConsole {
            
              // 객체가 다른 객체를 자신의 멤버로 Has 하고 그것을 이용하면 이러한 관계를 Has A 상속이라고 한다.
              private Lotto lotto; // LottoConsole은 Lotto를 상속(제공) 받아서 멤버 함수를 구현한다.

              public LottoConsole(Lotto lotto) { 
                this.lotto = lotto; 
              }

              // 로또 출력
              public void print() { 
                System.out.print("로또 번호: ");

                for(int i=0; i<this.lotto.getSize(); i++) {
                  System.out.print(this.lotto.getNum(i)); 

                  if(i < this.lotto.getSize()-1)
                    System.out.print(", ");
                }	
              }
            } 
            ```
        - Is A 상속: 내일 배울 예정!
- **오후(프론트엔드)**
  - 오후에는 **텍스트가 위치했던 곳에 텍스트 대신 이미지 배치하기, CSS 코드 집중화, 우선순위를 주는 속성**에 대해 배워보았다.
    1. **텍스트 대신 이미지 배치하기**
      ```css
      .customer-menu .mypage-button {
          background: url("../images/txt-mypage.png") no-repeat center/* x, y 좌표 모두 center */;
          width: 72px; 
          height: 17px;
          display: inline-block; /* 너비와 높이를 가지게 하기 위함 */
          text-indent: -999px; /* 아예 왼쪽으로 들여쓰기 해서 이미지의 너비가 오른쪽으로 커지더라도 왼쪽으로 들여쓰기된 글자가 보이지 않게 만들기 */
          overflow: hidden; /* 왼쪽 또는 오른쪽으로 overflow된 요소가 있으면 보이지 않게 하기 */
    }
      ```
    2. **CSS 코드 집중화**
        - 집중화하고 싶은 코드를 아래와 같이 한 군데에 작성해놓는다.
          ```css
          .button { 
              display: inline-block;
              text-indent: -999px; 
              overflow: hidden; 
          }
          ```
        - 집중화한 코드를 적용한다.
          ```css
          <li><a class="button mypage-button" href="">마이페이지</a></li>
          ```
    3. **우선순위 주기**
        - `!important`: 다른 것보다 이 스타일이 우선순위를 갖게 된다.
          ```css
          .d-none {
              display: none !important;
          }
          ```
          
<br>

# 3월 31일 (수)
## 공부한 내용
### 자바 국비지원 수업
- **오전(백엔드)**
  - 오전에는 **Is A 상속**에 대해 알아보고, 관련 코드를 작성해보는 시간을 가졌다.
    1. **Is A 상속**    
        - 부모 클래스가 가지고 있는 것을 자식클래스가 물려받아 같이 공유하며 나아가 확장(extends)하는 개념
        - 기존 객체(부모 클래스)를 부품으로 사용하는 것이 아닌 기존 객체를 틀로 가져온 뒤 수정해 사용함
        - 틀로써 상속: 동일한 객체를 이용, 동일한 객체를 상속받음
    2. **부모 클래스 Exam를 상속받기**
        - extends 키워드 사용하기
          ```java
          public class NewExam extends Exam/* extends를 이용해 부모 객체 Exam를 틀로 가져옴 */{
              private int com;

              public NewExam() {
                  // super(); 자식 객체(NewExam) 생성 시 부모 객체(Exam)의 생성자가 자동으로 호출되어 부모 객체도 함께 생성된다.
                  com = 10;
              }

              // Override해서 부모 객체의 메소드를 수정해서 사용하기
              @Override
              public int total() {
                  return super.total() + com; // super를 생략하게 되면 super 대신 this가 붙게 됨
                                    // 현재 객체(NewExam)가 가지고 있는 total()을 계속 호출(재귀 호출)해서 무한 루프에 빠지게 됨
                                    // 경우에 따라 부모가 가지고 있는 것을 호출할 때는 super를 꼭 명시해야함
              }

              @Override
              public float avg() {
                  return total() / 4.0f;
              }
            
          }
          ```
- **오후(프론트엔드)**
  - **입력 폼 태그와 텍스트를 수평, 수직 정렬하는 법**을 알아보았다.
    1. **입력 폼 태그(form)**   
        ![1 (14) (1)](https://user-images.githubusercontent.com/53208493/113140813-e0734380-9263-11eb-9462-c7451ce84a1b.png)      
        - fieldset: HTML 양식 속에서 그룹을 만드는 태그   
        - legend: 그룹으로 묶는 구역에 제목을 붙이는 태그
        - label: 폼 요소에 레이블(텍스트)을 붙이는 태그
        - input[type=text]: 입력칸 생성
        - input[type=checkbox]: 체크박스 생성, 다중 선택 가능
        - input[type=radio]: 라디오 버튼 생성, 단일 선택 가능(다중 선택 불가)
        - textarea: 여러 줄의 텍스트 입력 가능한 입력칸 생성
          ```css
          <form>
              <fieldset> <!--  다른 필드셋과 구분해주고 싶을 때 사용 -->
                  <legend>과정 검색 필드</legend> <!-- 필드셋에 대한 라벨 -->
                  <label>과정 검색</label>
                  <input type="text">
                  <input type="submit" value="검색">
              </fieldset> 
          </form>
          ```
    3. **텍스트 정렬**
        - 수평 정렬: `text-align: center;`
        - 수직 정렬: `line-height: 20px;` (텍스트를 둘러싼 박스와 같은 높이 부여하기)
