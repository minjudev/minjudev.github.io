해당 글은 구름EDU의 **"한 눈에 끝내는 Node.js"** 를 학습한 뒤 요약해 작성한 글입니다.

## 1. Node.js란?
- 서버사이드 자바스크립트
- 구글의 자바스크립트 엔진인 V8을 기반으로 구성된 일종의 소프트웨어 시스템
- 비동기식 프로그래밍이 가능

### 1) 노드의 탄생 배경
- 2009년 라이언 달(Ryan Dahl)이 고안해 낸 언어
- 탄생 배경: 다수의 연결을 효율적으로 관리, 비용 최소화할 수 있는 네트워크 소프트웨어를 개발하는 편리한 방법 제공하기 위해 개발됨
- 자바스크립트는 서버에서 사용하고자 하는 노력이 반영된 결과

기존에는 어떤 클라이언트가 웹 서버에 연결을 요청하면, 일정 메모리 공간을 사용해 새로운 쓰레드를 생성했다.  
이렇게 웹 애플리케이션을 개발해 서비스를 제공하는 경우에는 더 많은 사용자를 지원하기 위해서 사업자는 더 많은 서버를 추가해야한다.  
이는 서버 구매 비용뿐만 아니라 이를 운영하는 비용, 운영에 따라 발생하는 트래픽 비용, 인건비 등 여러 비용이 뒤따라오는 결과를 낳게 되었다.  

이러한 문제들을 해결하기 위해 등장한 것이 바로 노드이다.  
노드는 서버에서 클라이언트로부터의 요청, 즉 **연결을 처리하는 방법을 새로운 컨셉으로 변경**하게 된다.  
기존에는 각 연결에 대해 새로운 쓰레드를 생성하고 그에 따라 메모리를 할당해 클라이언트의 요청을 처리했다면,  
노드에서는 **각 연결이 하나의 이벤트로서 노드 엔진에서 처리**된다.

### 2) Node.js를 사용하는 서비스들
- Walmart: 월마트는 자사의 모바일 앱 백엔드 서비스를 노드로 활용하고 있다.  
- LinkedIn: 링크드인은 자신들의 메인 서비스 개발을 Ruby On Rails에서 노드로 변경한 뒤, 기존에 비해 두 배에 달하는 트래픽을 단지 4개의 인스턴스만으로 운영이 가능하다고 밝혔다.
- Cloud9 IDE: Cloud9 IDE는 노드로 웹 애플리케이션을 개발할 수 있는 환경을 제공하며, 그 서비스 자체도 노드를 이용해 개발되어 있다.  

## 2. 이벤트 기반 비동기 방식
노드의 뛰어난 성능의 이유
- 비동기 이벤트 기반 아키텍처
- 구글 V8 자바스크립트 엔진 이용

### 1) 쓰레드 기반 VS 비동기 이벤트 기반
지금까지 대부분의 애플리케이션은 Blocking I/O를 사용, 이 때문에 멀티 쓰레드를 사용해야 했다.  
하지만, 멀티 쓰레드는 네트워크에서 동시에 대규모 요청을 동시에 처리하는 데에는 부적합하다.  

### 2) Blocking I/O 
일반적인 애플리케이션들은 거의 대부분 Blocking I/O를 사용한다.  
Blocking I/O는 **"하나의 프로세스가 어떤 자원을 사용하고자 할 때, 그 자원을 다른 프로세스가 점유하고 있다면  
다른 프로세스가 그 자원의 사용을 마칠 때까지 기다려야 한다"** 는 것을 의미한다.  

예를 들어, 어떤 애플리케이션이 운영체제의 커널에게 파일을 읽기 위해 시스템 콜이라는 형태로 요쳥을 보냈다고 가정해보자.  
이 때 커널은 파일을 읽기 위한 동작을 수행하기 시작하고 애플리케이션은 커널이 파일을 다 읽을 때까지 기다려야 한다.  
일반적으로 이 상태를 애플리케이션이 **Blocked** 되었다고 표현하고, 이 상태에서 실제로 애플리케이션은 아무 것도 하지 않게 된다.  

### 3) 멀티 쓰레드
웹서버와 같이 다수의 요청이 들어오게 되면 그 일을 처리하기 위해 멀티 쓰레드라는 개념을 사용할 수 밖에 없게 된다.  

멀티 쓰레드는 **쓰레드 여러 개가 동시에 실행되어 요청을 처리**한다는 개념이다.  
이는 CPU의 시분할이라는 개념으로 설명될 수 있다.  
시분할 개념은 하나의 CPU를 여러 프로세스 또는 쓰레드가 시간을 나누어 동작하도록 하는 것을 통해,  
마치 CPU를 공유해 사용하는 것과 같은 효과를 낸다.  

<img width="369" alt="멀티 쓰레드" src="https://user-images.githubusercontent.com/53208493/80267614-e7e9ae80-86dc-11ea-9317-52193741f175.PNG">

***이미지 출처 - 구름 EDU 한 눈에 끝내는 Node.js 중 04. Node.js 소개(23p)***   

위 그림을 순서대로 살펴보자.
1. 첫 번째 그림은 시분할을 이용하지 않고 **싱글 쓰레드**로 요청을 처리하는 모습이다.  
이러한 형태는 먼저 들어온 요청을 우선적으로 처리하고 이 요청에 대한 처리가 끝날 때까지 기다린 후에 다음 요쳥을 처리하게 된다. 그렇기 때문에, 먼저 요청한 작업이 먼저 응답을 받을 수 있다. 
2. 두 번째 그림은 **단순한 프로세스 스케줄링**을 적용한 경우이다.  
이는 특정 쓰레드가 일정 시간만 CPU를 사용할 수 있게 되어있다.   
따라서, 그림에서 프로세스 C가 가장 늦게 요청을 했지만 가장 먼저 응답을 받게 된다.  
3. 세 번째 그림은 CPU를 사용할 수 있는 시간이 더 적게 설정된 경우이다.   
이러한 경우에도 먼저 요청이 온 A보다 B가 먼저 작업을 마치고 응답을 할 수 있게 된다.  

### 4) 쓰레드로 인해 발생하는 문제
위에서 살펴본 것처럼 멀티 쓰레드를 통해 다수의 요청으로 인해 발생하는 공유 문제는 해결할 수 있었다.  
하지만, 공유 문제를 해결하는 것과는 별개로 쓰레드 기반으로 동작할 때 발생하는 실질적인 문제점은 무엇일까?  

**(1) Blocking I/O 자체가 발생시키는 쓰레드 지연에 대한 문제**    
I/O 요청을 하고 응답을 받을 때까지 아무 것도 하지 않고 시간을 낭비한다는 문제가 여전히 남아있다.  

**(2) 스케줄링을 위한 처리 시간과 문맥 전환(Context switch) 비용 발생**  
쓰레드를 분배하여 사용하기 위해서는 사용하는 스케줄링 그 자체도 CPU를 이용한 연산이 필요하고,  
쓰레드 간의 문맥 전환을 위해서 전환하기 직전의 쓰레드를 다시 복귀시킬 때를 대비해 그 상태를 저장해둬야 하는데,  
이것 또한 CPU를 이용한 연산이 필요한 작업이다.  

### 5) 싱글 쓰레드와 이벤트 기반의 비동기 I/O 처리
위에서 살펴본 문제를 개선하기 위해 노드는 **싱글 쓰레드**와 **이벤트 기반의 비동기 I/O 처리**로 해결하고 있다.  

싱글 쓰레드를 가진 노드는 I/O 작업이 시작되면 I/O 작업 처리가 끝날 때까지 응답을 기다리지 않고, 바로 다음 작업을 실행한다. 대신 I/O 작업이 종료되면 이벤트를 발생시키고, 이 이벤트는 해당 프로세스의 이벤트 큐에 등록된다.  
노드로 개발된 프로세스는 이 이벤트 큐에 등록된 새로운 이벤트를 감지해, 해당 이벤트가 발생했을 시 수행해야 할 작업을 실행하게 된다.   

### 6) 이벤트 루프(Event Loop)
이벤트 루프란 작업을 요청하면서 그 작업이 완료됐을 때 어떤 작업을 진행할지에 대한 콜백 함수를 지정해,  
**동작이 완료되었을 때 해당 콜백 함수를 실행하는 방식의 동작 방식**을 말한다.

<img width="368" alt="이벤트 루프" src="https://user-images.githubusercontent.com/53208493/80272738-08c6f980-8707-11ea-9845-988637c7aff1.PNG">


***이미지 출처 - 구름 EDU 한 눈에 끝내는 Node.js 중 04. Node.js 소개(23p)*** 

위 그림을 통해 이벤트 루프가 동작하는 방식을 살펴보자.  
1. 클라이언트가 웹 서버에 HTTP 형식으로 요청한다.
2. 서버에서 이벤트 루프가 계속 돌고 있다가 요청을 감지하고 알맞은 작업을 워커 쓰레드를 생성하여 실행한다.  
3. 이벤트 루프는 워커 쓰레드의 응답을 기다리지 않고, 바로 루프로 복귀하여 다른 요청을 기다린다.
4. 워커 쓰레드가 모든 작업을 마치면 미리 전달받은 콜백 함수를 실행하도록 이벤트 루프에 응답하게 된다.
5. 이벤트 루프는 해당 콜백 함수를 실행하여 클라이언트에게 결과를 응답해준다.  
